"""
AI Service - Handles all AI-related functionalities
"""
import os
from typing import List, Dict
from difflib import SequenceMatcher

class AIService:
    """AI service for mentor matching, ranking, and advice generation"""

    def __init__(self):
        # In a real implementation, this would use OpenAI API or similar
        # For now, we'll use rule-based and keyword matching
        self.career_paths = [
            'Software Engineering', 'Data Science', 'Machine Learning',
            'Web Development', 'Cybersecurity', 'Cloud Computing',
            'Business Analytics', 'Product Management', 'Research',
            'Teaching', 'Consulting', 'Entrepreneurship'
        ]

    def get_academic_advice(self, query: str, student: Dict) -> str:
        """
        Get AI-generated academic advice
        In production, this would call an LLM API
        """
        # Context-aware advice based on student profile
        weakness_areas = student.get('weakness_areas', [])

        # Generate contextual advice
        advice = f"""
Based on your query: "{query}"

Here's some academic guidance:

1. **Focus Areas**: {" and ".join(weakness_areas) if weakness_areas else "Continue building on your strengths"}

2. **Study Strategy**:
   - Create a structured study schedule
   - Practice regularly with sample problems
   - Review concepts daily to reinforce learning

3. **Resources**:
   - Utilize online tutorials and practice platforms
   - Join study groups for collaborative learning
   - Seek help from your mentor regularly

4. **Progress Tracking**:
   - Set weekly goals and track your progress
   - Review past performance to identify patterns
   - Celebrate small wins to stay motivated

**Disclaimer**: This advice is AI-generated and should be used as a supplement to professional academic guidance. Always consult with your mentor or academic advisor for personalized recommendations.

*Generated by AI Academic Advisor*
        """
        return advice.strip()

    def get_assessment_questions(self) -> List[Dict]:
        """Get psychometric assessment questions"""
        return [
            {
                'id': 1,
                'question': 'I enjoy solving complex problems and puzzles',
                'category': 'analytical'
            },
            {
                'id': 2,
                'question': 'I prefer working in teams rather than alone',
                'category': 'collaboration'
            },
            {
                'id': 3,
                'question': 'I am comfortable with mathematical concepts',
                'category': 'technical'
            },
            {
                'id': 4,
                'question': 'I enjoy creative and artistic activities',
                'category': 'creative'
            },
            {
                'id': 5,
                'question': 'I like to lead and take initiative',
                'category': 'leadership'
            },
            {
                'id': 6,
                'question': 'I prefer structured and organized work environments',
                'category': 'organization'
            },
            {
                'id': 7,
                'question': 'I am interested in understanding how things work',
                'category': 'technical'
            },
            {
                'id': 8,
                'question': 'I enjoy helping others learn and grow',
                'category': 'teaching'
            },
            {
                'id': 9,
                'question': 'I am comfortable with uncertainty and ambiguity',
                'category': 'adaptability'
            },
            {
                'id': 10,
                'question': 'I prefer working with data and analytics',
                'category': 'data'
            }
        ]

    def generate_career_assessment(self, student_id: int, answers: Dict) -> Dict:
        """Generate career assessment based on answers"""
        # Calculate scores for each category
        category_scores = {}
        for key, value in answers.items():
            if key.startswith('q_'):
                question_id = int(key.split('_')[1])
                questions = self.get_assessment_questions()
                question = next((q for q in questions if q['id'] == question_id), None)
                if question:
                    category = question['category']
                    score = int(value)
                    if category not in category_scores:
                        category_scores[category] = []
                    category_scores[category].append(score)

        # Calculate average scores
        avg_scores = {cat: sum(scores) / len(scores) for cat, scores in category_scores.items()}

        # Determine top strengths
        top_categories = sorted(avg_scores.items(), key=lambda x: x[1], reverse=True)[:3]

        # Match to career paths
        recommended_paths = self._match_career_paths(top_categories)

        # Generate report
        report = {
            'id': 0,  # Will be set by data service
            'student_id': student_id,
            'category_scores': avg_scores,
            'top_strengths': [cat for cat, _ in top_categories],
            'recommended_careers': recommended_paths,
            'summary': self._generate_assessment_summary(top_categories, recommended_paths),
            'status': 'pending_verification'
        }

        return report

    def _match_career_paths(self, top_categories: List[tuple]) -> List[str]:
        """Match assessment results to career paths"""
        category_to_career = {
            'analytical': ['Data Science', 'Research', 'Software Engineering'],
            'technical': ['Software Engineering', 'Machine Learning', 'Cybersecurity'],
            'creative': ['Web Development', 'Product Management', 'Teaching'],
            'leadership': ['Product Management', 'Consulting', 'Entrepreneurship'],
            'teaching': ['Teaching', 'Consulting', 'Research'],
            'data': ['Data Science', 'Business Analytics', 'Machine Learning'],
            'collaboration': ['Product Management', 'Consulting', 'Teaching']
        }

        recommended = set()
        for category, _ in top_categories:
            if category in category_to_career:
                recommended.update(category_to_career[category])

        return list(recommended)[:5] if recommended else ['General Professional']

    def _generate_assessment_summary(self, top_categories, recommended_paths):
        """Generate assessment summary text"""
        return f"""
        Based on your assessment, your top strengths are: {', '.join([cat for cat, _ in top_categories])}.

        Recommended career paths:
        {chr(10).join(f'- {path}' for path in recommended_paths)}

        These recommendations are based on your responses and should be discussed with your mentor for personalized guidance.
        """

    def suggest_resources(self, student: Dict) -> List[Dict]:
        """Suggest learning resources based on student profile"""
        weakness_areas = student.get('weakness_areas', [])
        resources = []

        for area in weakness_areas:
            resources.append({
                'area': area,
                'type': 'Online Course',
                'title': f'{area} Fundamentals Course',
                'url': '#',
                'description': f'Comprehensive course covering {area} basics and advanced topics'
            })
            resources.append({
                'area': area,
                'type': 'Tutorial',
                'title': f'{area} Practice Problems',
                'url': '#',
                'description': f'Interactive practice problems and exercises for {area}'
            })
            resources.append({
                'area': area,
                'type': 'Research Paper',
                'title': f'Recent Advances in {area}',
                'url': '#',
                'description': f'Academic research papers on {area}'
            })

        return resources[:6]  # Limit to 6 resources

    def match_mentor(self, student: Dict, available_mentors: List[Dict]) -> List[Dict]:
        """
        Match student to mentors using keyword-based similarity
        Returns ranked list of mentor recommendations
        """
        student_weaknesses = set(student.get('weakness_areas', []))

        mentor_scores = []
        for mentor in available_mentors:
            mentor_expertise = set(mentor.get('expertise', []))

            # Calculate similarity score
            if student_weaknesses and mentor_expertise:
                # Jaccard similarity
                intersection = student_weaknesses.intersection(mentor_expertise)
                union = student_weaknesses.union(mentor_expertise)
                similarity = len(intersection) / len(union) if union else 0
            else:
                similarity = 0.5  # Default score if no overlap

            # Add mentor rating as bonus
            rating = mentor.get('rating', 0) / 5.0
            total_score = (similarity * 0.7) + (rating * 0.3)

            mentor_scores.append({
                'mentor': mentor,
                'score': total_score,
                'match_reason': f"Expertise in: {', '.join(mentor_expertise)}"
            })

        # Sort by score descending
        mentor_scores.sort(key=lambda x: x['score'], reverse=True)
        return mentor_scores[:5]  # Top 5 recommendations

    def get_mentor_rankings(self) -> List[Dict]:
        """Calculate and return mentor performance rankings"""
        # In a real implementation, this would calculate from feedback data
        # For now, return sample rankings
        return [
            {
                'rank': 1,
                'name': 'Dr. Sarah Johnson',
                'rating': 4.8,
                'students_mentored': 15,
                'sessions_completed': 45
            },
            {
                'rank': 2,
                'name': 'Prof. Michael Chen',
                'rating': 4.6,
                'students_mentored': 12,
                'sessions_completed': 38
            },
            {
                'rank': 3,
                'name': 'Dr. Emily Williams',
                'rating': 4.5,
                'students_mentored': 10,
                'sessions_completed': 32
            }
        ]

    def get_session_preparation_tips(self, mentor_id: int, student_id: int) -> List[str]:
        """
        Generate AI-powered session preparation tips for mentors
        Returns 3 actionable tips
        """
        # In production, this would analyze student data and generate tips
        tips = [
            "Review the student's recent performance trends, focusing on Mathematics and Physics where they've shown improvement.",
            "Prepare specific examples and practice problems related to their weakness areas to make the session more targeted.",
            "Set clear goals for this session and establish measurable outcomes to track progress effectively."
        ]
        return tips

    def generate_career_insights(self) -> Dict:
        """Generate insights about trending career opportunities"""
        return {
            'trending_careers': [
                {
                    'field': 'AI/ML Engineering',
                    'demand': 'High',
                    'skills': ['Python', 'TensorFlow', 'Data Analysis'],
                    'growth': '+25%'
                },
                {
                    'field': 'Cloud Computing',
                    'demand': 'High',
                    'skills': ['AWS', 'Azure', 'DevOps'],
                    'growth': '+20%'
                },
                {
                    'field': 'Cybersecurity',
                    'demand': 'Very High',
                    'skills': ['Network Security', 'Penetration Testing', 'Compliance'],
                    'growth': '+30%'
                }
            ],
            'summary': 'Technology roles continue to show strong growth, with emphasis on AI, cloud, and security.'
        }

